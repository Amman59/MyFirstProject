# MyFirstProject
Test project to learn features of Github.

The first thing I want to do is to make a simple print statement, which in itself may seem like a pointless endeavour, due to the fact that I have manually inputted the output, but this shall bear importance for 2 reasons.The first is that it will allow me to learn how to run, debug and push code onto a repository, and the other is that it will allow me to use a similar function at a later stage to output data which I have not manually input as text within the print function itself.

The second thing that I wanted to do is to add in the most basic math command possible. By assigning 2 numbers I want to create an output that wasnt manually typed in.Easy enough to write this and execute the function.

Next I want to try something that I read about recently which is called 'BubbleSort' (https://en.wikipedia.org/wiki/Bubble_sort). This Will take an array and sort it in order which has the potential to make visualising data much easier.Upon reading the afformentioned link, I can see there is a function called Timsort which I will will use.
    I wrote the algorithm to correctly sort a simple array, and during the debugging phase there was an issue in that Tuples can not be modified the same way that lists are, so I rectified this by converting array E into a list by name of C.

I want to try learning how to add a linear search. This is a method finding values in a list, and will be the first case where I use the input function.The function works, easy enough, but I wnat to have some fun with it and randomize everything I can possible do.For the sake of simplicity of this linear search, all numbers should probabaly be in the form of an integer, otherwise the probability of the query outpuuting positive would severly decrease. I have randomised the queried number (between 1 and 10), the arrays contents (values between 1 and 10), and the array should vary in length between 1 and 15 integers - which could make for some interesting statistics regarding probability of the linear search returning yes over a large sample size. This produces a simple probability density function where the probability can be defined as

                                        p(S)=1-q^n 

Where p(S) is defined as the probability of the linear search being succesful,n is the length of the list, q is equal to the number of queried numbers divided by the number of possible outcomes - which is equivilent to the probability of failure if the list contains just a single value. In this case the value of q can be defined as 1-(1/10)=0.9.

The next peice of code I have added is a simple representation of a random walk. I copied and pasted the code which is used to alter the graph (such as colour and width and so forth) so as to streamline the process. In the walk the person can walk either one space in the positve direction or one space in the negative direction with a probability of 50%. This is the most simple version of a Markov chain, where the next state of a stochastic process is dependent on the previous one. We can also see the law of large  numbers come in to play here, as we can make the number of steps larger and the mean position per unit 'step' tends towards 0.

I wanted to play around with this concept a bit more and see if I could vary any of the elements to make the risk/return better for a 50/50 gamble. I made a loop which performs an interesting function -  I changed the scalar by which the player moves based on the direction of the previous moved.If the player moved in the positive X direction then I would change it so that would walk 0.5 units in either direction, or if the player moved in the negative x direction, then I would change the scalar so that the player would move by 1.5. In theory as the number of turns tends towards infinity the distance travelled should be the same in this model, as well as the last as there should be a 50% split of 1.5 unit movements and 0.5 unit movements. In n tends to infinity I would therefor imagine the models to be the same as the likelehood of of moving further or less distance is equally weighted. Interestingly in this chain, even for small values of n, the total risk/return of the model remains the same - after 3 turns there are 8 possible outcomes - (2,2,1.5,1,0.5,-1,-1,-5). in the above model by the 3rd turn the possible outcomes are (3,1,1,1,-1,-1,-1,-3). In the short term then we can see that model 2 has a higher probability of providing upside (5/8 outcomes) but this comes at the cost of having a large downside in (1/8 cases) the chance of moving -5 units. Since the trade off is fair. We have so far defined the probability as being 50% for all outcomes, but what if this wasnt the case? if we were taking a move of less risk(0.5 units)could we then assume it would have greater chance of providing upside? My assumption, without having done any calculations, is that if the probabilites were inverted for 1.5 vs 0.5 units, then the overall risk profile in the long term would hold the same as the above models. 

I have now added in a 3rd model - this is meant to reflect equities, but I am having difficulties in showing risk vs reward - as equities have typically fared well in the long term, I wanted to add in larger risk and greater return.For simplicity I have increased the reward to 1.5 units of upside vs 1 unit of downside. By adjusting the probability of occurance so that loss is more likely (0.6) this means that as the number of trials tends to infinity the sum of the outcomes is still 0 as in models 1 and 2. All I have done here is to increase the volatility - this is not an accurate reflection of equities in the long term, as large cap equities have fared very well. I wanted to add in a linear function to represent a fixed income product to demonstrate the benefits of spreading risk across  portfolio. These two functions were combined with a conventional 60/40 spilt. these are randomly generated functions, of which the rules and bounds have been defined by my assumptions, but perhaps it would be better to get real data from a source which would look at a developed market.